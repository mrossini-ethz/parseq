(in-package :common-lisp-user)

(parseq:defrule terminal-t () t)
(parseq:defrule terminal-nil () nil)
(parseq:defrule terminal-symbol () 'a)
(parseq:defrule terminal-character () #\a)
(parseq:defrule terminal-string () "abc")
(parseq:defrule terminal-vector () #(1 2 3))
(parseq:defrule terminal-number () 5)
(parseq:defrule terminal-any-char () char)
(parseq:defrule terminal-any-stdchar () stdchar)
(parseq:defrule terminal-any-alpha () alpha)
(parseq:defrule terminal-any-digit () digit)
(parseq:defrule terminal-any-alphanumeric () alphanumeric)
(parseq:defrule terminal-any-byte () byte)
(parseq:defrule terminal-any-symbol () symbol)
(parseq:defrule terminal-any-keyword () keyword)
(parseq:defrule terminal-any-form () form)
(parseq:defrule terminal-any-atom () atom)
(parseq:defrule terminal-any-list () list)
(parseq:defrule terminal-any-cons () cons)
(parseq:defrule terminal-any-vector () vector)
(parseq:defrule terminal-any-number () number)
(parseq:defrule terminal-any-integer () integer)
(parseq:defrule terminal-any-string () string)
(parseq:defrule terminal-char-expr () (char "+a-zA-D7-9.;-"))

(parseq:defrule nonterminal-and () (and 'a 'b 'c))
(parseq:defrule nonterminal-and~ () (and~ 'a 'b 'c 'd))
(parseq:defrule nonterminal-and~~ () (and~~ (1 2 (1) (2 3)) 'a 'b 'c 'd))
(parseq:defrule nonterminal-and~~2 () (and~~ (* + parseq:?) 'a 'b 'c)) ;; <<-- FIXME: should not be necessary to prefix with "parseq:"
(parseq:defrule nonterminal-or () (or 'a 'b 'c))
(parseq:defrule nonterminal-not () (not 'a))
(parseq:defrule nonterminal-* () (* 'a))
(parseq:defrule nonterminal-+ () (+ 'a))
(parseq:defrule nonterminal-? () (? 'a))
(parseq:defrule nonterminal-& () (& 'a))
(parseq:defrule nonterminal-! () (! 'a))
(parseq:defrule nonterminal-rep () (rep 4 'a))
(parseq:defrule nonterminal-rep-b () (rep (4) 'a))
(parseq:defrule nonterminal-rep-ab () (rep (3 5) 'a))
(parseq:defrule nonterminal-rep-nil-b () (rep (nil 5) 'a))
(parseq:defrule nonterminal-rep-a-nil () (rep (3 nil) 'a))
(parseq:defrule nonterminal-rep-nil-nil () (rep (nil nil) 'a))
(parseq:defrule nonterminal-rep-* () (rep * 'a))
(parseq:defrule nonterminal-rep-+ () (rep + 'a))
(parseq:defrule nonterminal-rep-? () (rep parseq:? 'a)) ;; <<-- FIXME: should not be necessary to prefix with "parseq:"
(parseq:defrule nonterminal-list () (list 'a 'b))
(parseq:defrule nonterminal-string () (string #\a #\b))
(parseq:defrule nonterminal-vector () (vector 4 5))

(parseq:defrule parameter-terminal (x) x)
(parseq:defrule parameter-terminal-2 (x) x)
(parseq:defrule parameter-terminal-indirect () (parameter-terminal 'a))
(parseq:defrule parameter-repeat (x) (rep x 'a))
;; This is a convoluted test that uses nesting of nonterminals with parameters
(parseq:defrule parameter-slist (item sep) (and item (* (and sep item))))
(parseq:defrule parameter-slist-user-sep (y) (or 'b y))
(parseq:defrule parameter-slist-user (z) (parameter-slist 'a (parameter-slist-user-sep z)))
(parseq:defrule parameter-slist-user-user () (parameter-slist-user 'c))
(parseq:defrule parameter-constant (x) 'a (:constant x))
(parseq:defrule parameter-optional (&optional (x 5 x-p)) 'a (:constant (list x x-p)))
(parseq:defrule parameter-keyword (&key ((:x xx) 5 x-p)) 'a (:constant (list xx x-p)))
(parseq:defrule parameter-rest (&rest x) 'a (:constant x))

(parseq:defrule option-constant () (and 'a 'b 'c) (:constant 4))
(parseq:defrule option-lambda () (and 'a 'b 'c) (:lambda (x y z) (list z y x)))
(parseq:defrule option-lambda-rest () (and 'a 'b 'c) (:lambda (&rest items) (reverse items)))
(parseq:defrule option-destructure () (and (* 'a) 'b) (:destructure ((&rest a) b) `(,@a ,b)))
(parseq:defrule option-choose () (and 'a (* 'b) (rep 1 'c) (? (and (+ 'd) 'e)) 'f) (:choose 0 0 '(1 5) 2 '(3 1) '(3 0 0) -1 -10))
(parseq:defrule option-identity-t () (and 'a 'b 'c) (:identity t))
(parseq:defrule option-identity-n () (and 'a 'b 'c) (:identity nil))
(parseq:defrule option-flatten () (and (and 'a 'b) (and 'c 'd) (and 'e 'f)) (:flatten))
(parseq:defrule option-string () (and (and #\a "b") "cd" (and #\e #\f)) (:string))
(parseq:defrule option-string-symbol () (and (and #\a "b") "cd" (and #\e 'f)) (:string))
(parseq:defrule option-vector () (and (and 1 2) (and 3 4) (and 5 6)) (:vector))
(parseq:defrule option-test () number (:test (x) (= x 5)))
(parseq:defrule option-not () number (:not (x) (= x 5)))

(parseq:defrule multiopt-proc () number (:lambda (x) (1+ x)) (:lambda (x) (1+ x)))
(parseq:defrule multiopt-test-a () number (:test (x) (= x 5)) (:lambda (x) (1+ x)))
(parseq:defrule multiopt-test-b () number (:lambda (x) (1+ x)) (:test (x) (= x 5)))

(parseq:defrule bind-single () (and bind-single-number bind-single-repeat) (:let x))
(parseq:defrule bind-single-number () number (:external x) (:lambda (num) (setf x num)))
(parseq:defrule bind-single-repeat () (rep x 'a) (:external x))
(parseq:defrule bind-nest-number () number (:external x) (:lambda (num) (setf x num)))
(parseq:defrule bind-nest-repeat () (rep x bind-single) (:external x) )
(parseq:defrule bind-nest () (and bind-nest-number bind-nest-repeat) (:let x))

(parseq:defrule nest-or-and () (or (and 'a 'b) (and 'a 'c) (and 'd 'e)))
(parseq:defrule nest-and-or () (and (or 'a 'b) (or 'a 'c) (or 'd 'e)))
(parseq:defrule nest-*-and () (* (and 'a 'b)))
(parseq:defrule nest-and-* () (and (* 'a) (* 'b)))
(parseq:defrule nest-+-and () (+ (and 'a 'b)))
(parseq:defrule nest-and-+ () (and (+ 'a) (+ 'b)))
(parseq:defrule nest-list-list () (list (list 'a)))

(parseq:defrule parse-error () (and terminal-symbol (or (and 'b (* 'd) (parameter-terminal 'e)) (and 'c (or 'g 'h)) (and 'b 'f))))

(parseq:defrule recursion () (or (and 'a recursion) 'a))
(parseq:defrule left-recursion () (or (and 'a left-recursion 'b) (and left-recursion 'a) 'a))
(parseq:defrule left-recursion-indirect () (and (? 'b) left-recursion-indirect-2))
(parseq:defrule left-recursion-indirect-2 () (and (? 'b) left-recursion-indirect))

(parseq:defrule packrat-symbol () symbol (:packrat t))
(parseq:defrule packrat-symbol-user () (+ packrat-symbol))
(parseq:defrule packrat-a (a b c) 'a (:external x y z) (:constant (list a b c x y z)) (:packrat t))
(parseq:defrule packrat-b () 'b (:packrat t))
(parseq:defrule packrat-ab (a b c) (and (packrat-a a b c) packrat-b))
(parseq:defrule packrat-ab-2 (a b c) (and (packrat-a a b c) packrat-b) (:let (z 7)))
(parseq:defrule packrat-abc-1 () (or (and (packrat-ab 1 2 3) 'c) (packrat-ab 1 2 3)) (:let (x 4) (y 5) (z 6)))
(parseq:defrule packrat-abc-2 () (or (and (packrat-ab 1 2 3) 'c) (packrat-ab 1 2 4)) (:let (x 4) (y 5) (z 6)))
(parseq:defrule packrat-abc-3 () (or (and (packrat-ab 1 2 3) 'c) (packrat-ab-2 1 2 3)) (:let (x 4) (y 5) (z 6)))

(parseq:defrule loop-name () (and 'named symbol))
(parseq:defrule loop-iteration-with () (and 'with symbol '= form (* (and 'and symbol '= form))))
(parseq:defrule loop-iteration-up () (and (? (and (or 'from 'upfrom) form)) (? (and (or 'upto 'to 'below) form))))
(parseq:defrule loop-iteration-down1 () (and 'from form (or 'downto 'above) form))
(parseq:defrule loop-iteration-down2 () (and 'downfrom form (? (and (or 'downto 'to 'above) form))))
(parseq:defrule loop-iteration-numeric () (and (or loop-iteration-down1 loop-iteration-down2 loop-iteration-up) (? (and 'by form))))
(parseq:defrule loop-iteration-list () (and (or 'in 'on) form (? (and 'by form))))
(parseq:defrule loop-iteration-flex () (and '= form (? (and 'then form))))
(parseq:defrule loop-iteration-vector () (and 'across form))
(parseq:defrule loop-iteration-key () (and (or 'hash-key 'hash-keys) (or 'of 'in) form (? (and 'using (list (and 'hash-value symbol))))))
(parseq:defrule loop-iteration-value () (and (or 'hash-value 'hash-values) (or 'of 'in) form (? (and 'using (list (and 'hash-key symbol))))))
(parseq:defrule loop-iteration-package () (and (or 'symbol 'symbols 'present-symbol 'present-symbols 'external-symbol 'external-symbols) (or 'of 'in) form))
(parseq:defrule loop-iteration-hash () (and 'being (or 'the 'each) (or loop-iteration-key loop-iteration-value loop-iteration-package)))
(parseq:defrule loop-iteration-for-body () (or loop-iteration-list loop-iteration-flex loop-iteration-vector loop-iteration-hash loop-iteration-numeric))
(parseq:defrule loop-iteration-for () (and (or 'for 'as) symbol loop-iteration-for-body (* (and 'and symbol loop-iteration-for-body))))
(parseq:defrule loop-iteration () (or loop-iteration-with loop-iteration-for))
(parseq:defrule loop-around () (and (or 'initially 'finally) (+ (not loop-post-iteration))))
(parseq:defrule loop-repeat () (and 'repeat form))
(parseq:defrule loop-test () (and (or 'while 'until 'always 'never 'thereis) form))
(parseq:defrule loop-control () (or loop-around loop-repeat loop-test))
(parseq:defrule loop-do () (and (or 'do 'doing) (+ (not loop-post-iteration))))
(parseq:defrule loop-condition-and () (and loop-action (* (and 'and loop-action))))
(parseq:defrule loop-condition () (and (or 'if 'when 'unless) form loop-condition-and (? (and 'else loop-condition-and)) (? 'end)))
(parseq:defrule loop-return () (and 'return (or 'it form)))
(parseq:defrule loop-collect () (and (or 'collect 'collecting 'append 'appending 'nconc 'nconcing) (or 'it form) (? (and 'into form))))
(parseq:defrule loop-stat () (and (or 'count 'counting 'sum 'summing 'maximize 'maximizing 'minimize 'minimizing) (or 'it form) (? (and 'into form))))
(parseq:defrule loop-action () (or loop-do loop-condition loop-return loop-collect loop-stat)) ;; +
(parseq:defrule loop-post-iteration () (or loop-control loop-action))
(parseq:defrule loop () (and (? loop-name) (* loop-iteration) (* loop-post-iteration)))

(parseq:defrule url () (or url-generic url-httpaddress))
(parseq:defrule url-generic () (and url-scheme ":" url-path (? (and "?" url-search))))
(parseq:defrule url-scheme () url-ialpha (:string))
(parseq:defrule url-httpaddress () (and "http://" url-hostport (? (and #\/ url-path)) (? (and #\? url-search)))
  (:destructure (scheme (host port) path search)
                (list scheme
                      host
                      (if port (second port))
                      (if path (second path))
                      (if search (second search)))))
(parseq:defrule url-hostport () (and url-host (? (and #\: url-port))))
(parseq:defrule url-host () (or url-hostname url-hostnumber) (:string))
(parseq:defrule url-hostname () (and url-ialpha (? (and #\. url-hostname))))
(parseq:defrule url-hostnumber () (and url-digits #\. url-digits #\. url-digits #\. url-digits))
(parseq:defrule url-port () url-digits (:string) (:function #'parse-integer))
(parseq:defrule url-path () (and url-xpalphas (? (and #\/ url-path))) (:string))
(parseq:defrule url-search () (and url-xalphas (? (and #\+ url-search))) (:destructure (str more) (append (list str) (if more (second more)))))
(parseq:defrule url-xalpha () (or url-alpha url-digit url-safe url-extra url-escape))
(parseq:defrule url-xalphas () (+ url-xalpha) (:string))
(parseq:defrule url-xpalpha () (or url-xalpha #\+))
(parseq:defrule url-xpalphas () (+ url-xpalpha))
(parseq:defrule url-ialpha () (and url-alpha (? url-xalphas)))
(parseq:defrule url-alpha () char (:test (x) (alpha-char-p x)))
(parseq:defrule url-digit () char (:test (x) (digit-char-p x)))
(parseq:defrule url-digits () (+ url-digit))
(parseq:defrule url-safe () (or #\$ #\- #\_ #\@ #\. #\&))
(parseq:defrule url-extra () (or #\! #\* #\" #\' #\( #\) #\; #\, #\Space))
(parseq:defrule url-escape () (and #\% url-hex url-hex))
(parseq:defrule url-hex () (or url-digit #\a #\b #\c #\d #\e #\f #\A #\B #\C #\D #\E #\F))

;; ----- Helpers ----------------------------------------

(defun xnor (&rest forms)
  (evenp (count-if #'identity forms)))

(defun shuffle (list)
  "Creates a new list in which the items of the given list are shuffled"
  ;; Algorithm by Donald Knuth
  (let ((n (list-length list)) (result (copy-list list)))
    (loop for i below (- n 1) do
         (rotatef (nth i result) (nth (+ i (random (- n i))) result))
       finally (return result))))

(defmacro test-parseq (expression list &optional success (result nil result-p) junk-allowed (test 'equal))
  (if result-p
      `(,test (multiple-value-list (parseq:parseq ,expression ,list :junk-allowed ,junk-allowed)) (list ,result ,success))
      `(parseq:parseq ,expression ,list :junk-allowed ,junk-allowed)))

;; ----- Low level tests --------------------------------

(define-test treepos-test ()
  (check
    (equalp (parseq::make-treepos 1 2 3) #(1 2 3))
    (equalp (parseq::make-treepos) #(0))
    (condition= (parseq::make-treepos -1) error)
    (equalp (parseq::treepos-copy (parseq::make-treepos 1 2 3)) (parseq::make-treepos 1 2 3))
    (= (parseq::treepos-depth (parseq::make-treepos 1 2 3)) 3)
    (eql (parseq::treepos-valid (parseq::make-treepos 0) '()) nil)
    (eql (parseq::treepos-valid (parseq::make-treepos 0) '(a b)) t)
    (eql (parseq::treepos-valid (parseq::make-treepos 1) '(a b)) t)
    (eql (parseq::treepos-valid (parseq::make-treepos 2) '(a b)) nil)
    (eql (parseq::treepos-valid (parseq::make-treepos 0 0) '(a (b c))) nil)
    (eql (parseq::treepos-valid (parseq::make-treepos 1 0) '(a (b c))) t)
    (eql (parseq::treepos-valid (parseq::make-treepos 1 1) '(a (b c))) t)
    (eql (parseq::treepos-valid (parseq::make-treepos 1 2) '(a (b c))) nil)
    (eql (parseq::treepos-valid (parseq::make-treepos 2 0) '(a (b c))) nil)
    (equal (parseq::treeitem #() '(a b c d e)) '(a b c d e))
    (equal (parseq::treeitem (parseq::make-treepos) '(a b c d e)) 'a)
    (equal (parseq::treeitem (parseq::make-treepos 1 1) '(a (b b2) c d e)) 'b2)
    (condition= (parseq::treeitem (parseq::make-treepos 0 1) '(a (b b2) c d e)) error)
    (condition= (parseq::treeitem (parseq::make-treepos 1 2) '(a (b b2) c d e)) error)
    (= (parseq::treepos-length (parseq::make-treepos 1) '(a (b c) d)) 2)
    (condition= (parseq::treepos-length (parseq::make-treepos 0) '(a (b c) d)) parseq:generic-parse-error)
    (equalp (parseq::treepos-step (parseq::make-treepos 1)) (parseq::make-treepos 2))
    (equalp (parseq::treepos-step (parseq::make-treepos 1 2 3 4)) (parseq::make-treepos 1 2 3 5))
    (equalp (parseq::treepos-step-down (parseq::make-treepos 1)) (parseq::make-treepos 1 0))
    (equalp (parseq::treepos-step-down (parseq::make-treepos 1 2 3 4)) (parseq::make-treepos 1 2 3 4 0))
    (eql (parseq::treepos> (parseq::make-treepos 1) (parseq::make-treepos 1)) nil)
    (eql (parseq::treepos> (parseq::make-treepos 2) (parseq::make-treepos 1)) t)
    (eql (parseq::treepos> (parseq::make-treepos 1) (parseq::make-treepos 2)) nil)
    (eql (parseq::treepos> (parseq::make-treepos 1 2 3) (parseq::make-treepos 1 2 3)) nil)
    (eql (parseq::treepos> (parseq::make-treepos 1 2 4) (parseq::make-treepos 1 2 3)) t)
    (eql (parseq::treepos> (parseq::make-treepos 1 2 4) (parseq::make-treepos 1 3 3)) nil)
    (eql (parseq::treepos> (parseq::make-treepos 1 2 3) (parseq::make-treepos 1 2)) t)
    (eql (parseq::treepos> (parseq::make-treepos 1 2 3) (parseq::make-treepos 1 3)) nil)
    (eql (parseq::treepos> (parseq::make-treepos 1 3) (parseq::make-treepos 1 2 3)) t)
    (eql (parseq::treepos> (parseq::make-treepos 1 3) (parseq::make-treepos 1 3 3)) nil)
    (eql (parseq::treepos= (parseq::make-treepos 1 2 3) (parseq::make-treepos 1 2 3)) t)
    (eql (parseq::treepos= (parseq::make-treepos 1 2 3) (parseq::make-treepos 1 2 3 0)) nil)))

;; ----- High level tests -------------------------------

(define-test terminal-test ()
  (check
    (test-parseq 'terminal-t '(t) t t)
    (test-parseq 'terminal-t '(5) t 5)
    (test-parseq 'terminal-t '(nil) nil nil)
    (test-parseq 'terminal-nil '(nil) t nil)
    (test-parseq 'terminal-nil '(()) t nil)
    (test-parseq 'terminal-nil '(t) nil nil)
    (test-parseq 'terminal-symbol '(a) t 'a)
    (test-parseq 'terminal-symbol '(b) nil nil)
    (test-parseq 'terminal-symbol '(1) nil nil)
    (test-parseq 'terminal-character '(#\a) t #\a)
    (test-parseq 'terminal-character '(#\b) nil nil)
    (test-parseq 'terminal-character '(1) nil nil)
    (test-parseq 'terminal-string "abc" t "abc")
    (test-parseq 'terminal-string '("abc") t "abc")
    (test-parseq 'terminal-string '(1) nil nil)
    (test-parseq 'terminal-string "def" nil nil)
    (test-parseq 'terminal-vector #(1 2 3) t #(1 2 3) nil equalp)
    (test-parseq 'terminal-vector '(#(1 2 3)) t #(1 2 3) nil equalp)
    (test-parseq 'terminal-vector '((1 2 3)) nil nil)
    (test-parseq 'terminal-vector '("1 2 3") nil nil)
    (test-parseq 'terminal-vector #(4 5 6) nil nil nil equalp)
    (test-parseq 'terminal-number '(5) t 5)
    (test-parseq 'terminal-number '(4) nil nil)
    (test-parseq 'terminal-number '("abc") nil nil)
    (test-parseq 'terminal-any-char '(#\f) t #\f)
    (test-parseq 'terminal-any-char '(#\g) t #\g)
    (test-parseq 'terminal-any-char '(f) nil nil)
    (test-parseq 'terminal-any-stdchar '(#\f) t #\f)
    (test-parseq 'terminal-any-stdchar '(#\g) t #\g)
    (test-parseq 'terminal-any-stdchar '(#\Tab) nil nil)
    (test-parseq 'terminal-any-stdchar '(f) nil nil)
    (test-parseq 'terminal-any-alpha '(#\f) t #\f)
    (test-parseq 'terminal-any-alpha '(#\g) t #\g)
    (test-parseq 'terminal-any-alpha '(#\8) nil nil)
    (test-parseq 'terminal-any-alpha '(f) nil nil)
    (test-parseq 'terminal-any-digit '(#\7) t #\7)
    (test-parseq 'terminal-any-digit '(#\8) t #\8)
    (test-parseq 'terminal-any-digit '(#\f) nil nil)
    (test-parseq 'terminal-any-digit '(f) nil nil)
    (test-parseq 'terminal-any-alphanumeric '(#\f) t #\f)
    (test-parseq 'terminal-any-alphanumeric '(#\8) t #\8)
    (test-parseq 'terminal-any-alphanumeric '(#\Space) nil nil)
    (test-parseq 'terminal-any-alphanumeric '(f) nil nil)
    (test-parseq 'terminal-any-byte '(255) t 255)
    (test-parseq 'terminal-any-byte '(256) nil nil)
    (test-parseq 'terminal-any-byte '(0) t 0)
    (test-parseq 'terminal-any-byte '(-1) nil nil)
    (test-parseq 'terminal-any-byte '(a) nil nil)
    (test-parseq 'terminal-any-symbol '(f) t 'f)
    (test-parseq 'terminal-any-symbol '(#\f) nil nil)
    (test-parseq 'terminal-any-keyword '(:a) t :a)
    (test-parseq 'terminal-any-keyword '(a) nil nil)
    (test-parseq 'terminal-any-keyword '(#\a) nil nil)
    (test-parseq 'terminal-any-form '(nil) t nil)
    (test-parseq 'terminal-any-form '(#\a) t #\a)
    (test-parseq 'terminal-any-form '((foo)) t '(foo))
    (test-parseq 'terminal-any-atom '(nil) t nil)
    (test-parseq 'terminal-any-atom '(4) t 4)
    (test-parseq 'terminal-any-atom '((1 2)) nil nil)
    (test-parseq 'terminal-any-list '(nil) t nil)
    (test-parseq 'terminal-any-list '((+ 1 2)) t '(+ 1 2))
    (test-parseq 'terminal-any-list '(4) nil nil)
    (test-parseq 'terminal-any-cons '(nil) nil nil)
    (test-parseq 'terminal-any-cons '((1 . 2)) t '(1 . 2))
    (test-parseq 'terminal-any-cons '((1 2)) t '(1 2))
    (test-parseq 'terminal-any-cons '(4) nil nil)
    (test-parseq 'terminal-any-vector '(#(1 2)) t #(1 2) nil equalp)
    (test-parseq 'terminal-any-vector '(4) nil nil nil equalp)
    (test-parseq 'terminal-any-number '(4) t 4)
    (test-parseq 'terminal-any-number '(#\4) nil nil)
    (test-parseq 'terminal-any-integer '(4) t 4)
    (test-parseq 'terminal-any-integer '(4/5) nil nil)
    (test-parseq 'terminal-any-integer '(4.5) nil nil)
    (test-parseq 'terminal-any-integer '(#\4) nil nil)
    (test-parseq 'terminal-any-string '("foo") t "foo")
    (test-parseq 'terminal-any-string '(#\f) nil nil)
    ;; (char "+a-zA-D7-9.;-")
    (test-parseq 'terminal-char-expr "a" t #\a)
    (test-parseq 'terminal-char-expr "z" t #\z)
    (test-parseq 'terminal-char-expr "f" t #\f)
    (test-parseq 'terminal-char-expr "A" t #\A)
    (test-parseq 'terminal-char-expr "B" t #\B)
    (test-parseq 'terminal-char-expr "D" t #\D)
    (test-parseq 'terminal-char-expr "E" nil nil)
    (test-parseq 'terminal-char-expr "Z" nil nil)
    (test-parseq 'terminal-char-expr "0" nil nil)
    (test-parseq 'terminal-char-expr "6" nil nil)
    (test-parseq 'terminal-char-expr "7" t #\7)
    (test-parseq 'terminal-char-expr "8" t #\8)
    (test-parseq 'terminal-char-expr "9" t #\9)
    (test-parseq 'terminal-char-expr "." t #\.)
    (test-parseq 'terminal-char-expr ";" t #\;)
    (test-parseq 'terminal-char-expr "-" t #\-)
    (test-parseq 'terminal-char-expr "+" t #\+)
    (test-parseq 'terminal-char-expr "," nil nil)))

(define-test and-test ()
  (check
    ;; (and 'a 'b 'c)
    (test-parseq 'nonterminal-and '(a b c) t '(a b c))
    (test-parseq 'nonterminal-and '(a b) nil nil)
    (test-parseq 'nonterminal-and '(a c) nil nil)
    (test-parseq 'nonterminal-and '(a) nil nil)))

(define-test and~-test ()
  (check
    ;; (and~ 'a 'b 'c 'd)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d)) t '(a b c d))

    (test-parseq 'nonterminal-and~ (shuffle '(a b c)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c)) nil nil)

    (test-parseq 'nonterminal-and~ '(a b c d a) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)
    (test-parseq 'nonterminal-and~ (shuffle '(a b c d a)) nil nil)

    ;; (and~~ (1 2 (1) (2 3)) 'a 'b 'c 'd)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d)) t '((a) (b b) (c) (d d d)))

    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b d d)) t '((a) (b b) () (d d)))

    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a a b b c d d)) nil nil)

    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d)) nil nil)

    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)
    (test-parseq 'nonterminal-and~~ (shuffle '(a b b c d d d d)) nil nil)

    ;; (and~~ (* + ?) 'a 'b 'c)
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a a a b b b c)) t '((a a a) (b b b) (c)))

    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))
    (test-parseq 'nonterminal-and~~2 (shuffle '(b b b c)) t '(() (b b b) (c)))

    (test-parseq 'nonterminal-and~~2 (shuffle '(a b)) t '((a) (b) ()))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a b)) t '((a) (b) ()))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a b)) t '((a) (b) ()))
    (test-parseq 'nonterminal-and~~2 (shuffle '(a b)) t '((a) (b) ()))

    (test-parseq 'nonterminal-and~~2 (shuffle '(a)) nil nil)
    (test-parseq 'nonterminal-and~~2 (shuffle '(b c c)) nil nil)))

(define-test or-test ()
  (check
    ;; (or 'a 'b 'c)
    (test-parseq 'nonterminal-or '(a) t 'a)
    (test-parseq 'nonterminal-or '(b) t 'b)
    (test-parseq 'nonterminal-or '(c) t 'c)
    (test-parseq 'nonterminal-or '(d) nil nil)))

(define-test not-test ()
  (check
    ;; (not 'a)
    (test-parseq 'nonterminal-not '() nil nil)
    (test-parseq 'nonterminal-not '(a) nil nil)
    (test-parseq 'nonterminal-not '(b) t 'b)))

(define-test *-test ()
  (check
    ;; (* 'a)
    (test-parseq 'nonterminal-* '() t nil)
    (test-parseq 'nonterminal-* '(a) t '(a))
    (test-parseq 'nonterminal-* '(a a) t '(a a))
    (test-parseq 'nonterminal-* '(a a a) t '(a a a))
    (test-parseq 'nonterminal-* '(b) nil nil)
    (test-parseq 'nonterminal-* '(b) t nil t)
    (test-parseq 'nonterminal-* '(a b) nil nil)
    (test-parseq 'nonterminal-* '(a b) t '(a) t)))

(define-test +-test ()
  (check
    ;; (+ 'a)
    (test-parseq 'nonterminal-+ '() nil nil)
    (test-parseq 'nonterminal-+ '(a) t '(a))
    (test-parseq 'nonterminal-+ '(a a) t '(a a))
    (test-parseq 'nonterminal-+ '(a a a) t '(a a a))
    (test-parseq 'nonterminal-+ '(b) nil nil)
    (test-parseq 'nonterminal-+ '(a b) nil nil)
    (test-parseq 'nonterminal-+ '(a b) t '(a) t)))

(define-test ?-test ()
  (check
    ;; (? 'a)
    (test-parseq 'nonterminal-? '() t nil)
    (test-parseq 'nonterminal-? '(a) t 'a)
    (test-parseq 'nonterminal-? '(b) t nil t)))

(define-test &-test ()
  (check
    ;; (& 'a)
    (test-parseq 'nonterminal-& '(a) t 'a t)
    (test-parseq 'nonterminal-& '(b) nil nil t)))

(define-test !-test ()
  (check
    ;; (! 'a)
    (test-parseq 'nonterminal-! '() nil nil)
    (test-parseq 'nonterminal-! '(a) nil nil)
    (test-parseq 'nonterminal-! '(b) t 'b t)))

(define-test rep-test ()
  (check
    ;; (rep 4 'a)
    (test-parseq 'nonterminal-rep '() nil nil)
    (test-parseq 'nonterminal-rep '(a a a) nil nil)
    (test-parseq 'nonterminal-rep '(a a a a) t '(a a a a))
    (test-parseq 'nonterminal-rep '(a a a a a) nil nil)
    ;; (rep (4) 'a)
    (test-parseq 'nonterminal-rep-b '() t '())
    (test-parseq 'nonterminal-rep-b '(a) t '(a))
    (test-parseq 'nonterminal-rep-b '(a a) t '(a a))
    (test-parseq 'nonterminal-rep-b '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-b '(a a a a) t '(a a a a))
    (test-parseq 'nonterminal-rep-b '(a a a a a) nil nil)
    ;; (rep (nil 5) 'a)
    (test-parseq 'nonterminal-rep-nil-b '() t '())
    (test-parseq 'nonterminal-rep-nil-b '(a) t '(a))
    (test-parseq 'nonterminal-rep-nil-b '(a a) t '(a a))
    (test-parseq 'nonterminal-rep-nil-b '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-nil-b '(a a a a) t '(a a a a))
    (test-parseq 'nonterminal-rep-nil-b '(a a a a a) t '(a a a a a))
    (test-parseq 'nonterminal-rep-nil-b '(a a a a a a) nil nil)
    ;; (rep (3 5) 'a)
    (test-parseq 'nonterminal-rep-ab '(a a) nil nil)
    (test-parseq 'nonterminal-rep-ab '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-ab '(a a a a) t '(a a a a))
    (test-parseq 'nonterminal-rep-ab '(a a a a a) t '(a a a a a))
    (test-parseq 'nonterminal-rep-ab '(a a a a a a) nil nil)
    ;; (rep (3 nil) 'a)
    (test-parseq 'nonterminal-rep-a-nil '(a) nil nil)
    (test-parseq 'nonterminal-rep-a-nil '(a a) nil nil)
    (test-parseq 'nonterminal-rep-a-nil '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-a-nil '(a a a a) t '(a a a a))
    (test-parseq 'nonterminal-rep-a-nil '(a a a a a) t '(a a a a a))
    (test-parseq 'nonterminal-rep-a-nil '(a a a a a a) t '(a a a a a a))
    ;; (rep (nil nil) 'a)
    (test-parseq 'nonterminal-rep-nil-nil '() t '())
    (test-parseq 'nonterminal-rep-nil-nil '(a) t '(a))
    (test-parseq 'nonterminal-rep-nil-nil '(a a) t '(a a))
    (test-parseq 'nonterminal-rep-nil-nil '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-nil-nil '(a a a a) t '(a a a a))
    (test-parseq 'nonterminal-rep-nil-nil '(a a a a a) t '(a a a a a))
    (test-parseq 'nonterminal-rep-nil-nil '(a a a a a a) t '(a a a a a a))
    ;; (rep * 'a)
    (test-parseq 'nonterminal-rep-* '() t '())
    (test-parseq 'nonterminal-rep-* '(a) t '(a))
    (test-parseq 'nonterminal-rep-* '(a a) t '(a a))
    (test-parseq 'nonterminal-rep-* '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-* '(a a a a) t '(a a a a))
    ;; (rep + 'a)
    (test-parseq 'nonterminal-rep-+ '() nil nil)
    (test-parseq 'nonterminal-rep-+ '(a) t '(a))
    (test-parseq 'nonterminal-rep-+ '(a a) t '(a a))
    (test-parseq 'nonterminal-rep-+ '(a a a) t '(a a a))
    (test-parseq 'nonterminal-rep-+ '(a a a a) t '(a a a a))
    ;; (rep ? 'a)
    (test-parseq 'nonterminal-rep-? '() t '())
    (test-parseq 'nonterminal-rep-? '(a) t '(a))
    (test-parseq 'nonterminal-rep-? '(a a) nil nil)))

(define-test list-test ()
  (check
    ;; (list 'a)
    (test-parseq 'nonterminal-list '() nil nil)
    (test-parseq 'nonterminal-list '(a) nil nil)
    (test-parseq 'nonterminal-list '((a)) nil nil)
    (test-parseq 'nonterminal-list '((a b)) t '(a b))
    (test-parseq 'nonterminal-list '((a c)) nil nil)
    (test-parseq 'nonterminal-list '((b b)) nil nil)
    (test-parseq 'nonterminal-list '(#(a b)) nil nil)))

(define-test string-test ()
  (check
    ;; (string #\a)
    (test-parseq 'nonterminal-string '("") nil nil)
    (test-parseq 'nonterminal-string '("a") nil nil)
    (test-parseq 'nonterminal-string '("b") nil nil)
    (test-parseq 'nonterminal-string '("aa") nil nil)
    (test-parseq 'nonterminal-string '("ab") t '(#\a #\b))
    (test-parseq 'nonterminal-string '("bb") nil nil)
    (test-parseq 'nonterminal-string '((#\a #\b)) nil nil)))

(define-test string-type-test ()
  (check
    ;; These tests handle the subtle differences that led to the update of #'sequence=.
    ;; The update fixes every place that deals with strings (defrule too).
    ;; The observed specific types are enforced to guarantee test portability.
    (test-parseq 'terminal-string "abc" t "abc")
    (test-parseq 'terminal-string (coerce "abc" '(simple-array character (3))) t "abc")
    (test-parseq 'terminal-string (coerce "abc" '(simple-base-string 3)) t "abc")))

(define-test vector-test ()
  (check
    ;; (vector 4)
    (test-parseq 'nonterminal-vector '(#()) nil nil)
    (test-parseq 'nonterminal-vector '(#(3)) nil nil)
    (test-parseq 'nonterminal-vector '(#(4)) nil nil)
    (test-parseq 'nonterminal-vector '(#(4 4)) nil nil)
    (test-parseq 'nonterminal-vector '(#(4 5)) t '(4 5))
    (test-parseq 'nonterminal-vector '(#(5 5)) nil nil)
    (test-parseq 'nonterminal-vector '((4)) nil nil)))

(define-test parse-test ()
  (check
    ;; (vector 4)
    (condition= (parseq:parseq 'terminal-t '() :parse-error t) parseq:generic-parse-error)
    (condition= (parseq:parseq 'terminal-t '(1 2) :parse-error t) parseq:generic-parse-error)
    (= (parseq:parseq 'terminal-t '(1 2) :end 2 :parse-error t :junk-allowed t) 1)
    (condition= (parseq:parseq '(1 2) ()) parseq:invalid-rule-error)))

(define-test parameter-test ()
  (check
    ;; x
    (test-parseq '(parameter-terminal 'a) '(a) t 'a)
    (test-parseq '(parameter-terminal 'a) '(b) nil nil)
    (test-parseq '(parameter-terminal #\a) "a" t #\a)
    (test-parseq '(parameter-terminal #\a) "b" nil nil)
    (test-parseq '(parameter-terminal "abc") "abc" t "abc")
    (test-parseq '(parameter-terminal "abc") "def" nil nil)
    (test-parseq '(parameter-terminal "abc") '("abc") t "abc")
    (test-parseq '(parameter-terminal "abc") '("def") nil nil)
    (test-parseq '(parameter-terminal #(1 2 3)) #(1 2 3) t #(1 2 3) nil equalp)
    (test-parseq '(parameter-terminal #(1 2 3)) #(4 5 6) nil nil)
    (test-parseq '(parameter-terminal #(1 2 3)) '(#(1 2 3)) t #(1 2 3) nil equalp)
    (test-parseq '(parameter-terminal #(1 2 3)) '(#(4 5 6)) nil nil)
    (test-parseq '(parameter-terminal 5) '(5) t 5)
    (test-parseq '(parameter-terminal 5) '(6) nil nil)
    (test-parseq '(parameter-terminal terminal-t) '(1) t 1)
    (test-parseq '(parameter-terminal (parameter-terminal-2 'a)) '(a) t 'a)
    (condition= (parseq:parseq '(parameter-terminal #2A((3 4) (1 2))) '(a)) parseq:invalid-terminal-runtime-error)
    ;; (parameter-terminal 'a)
    (test-parseq 'parameter-terminal-indirect '(a) t 'a)
    ;; (rep x 'a))
    (test-parseq '(parameter-repeat 3) '(a a) nil nil)
    (test-parseq '(parameter-repeat 3) '(a a a) t '(a a a))
    (test-parseq '(parameter-repeat 3) '(a a a a) nil nil)
    ;; a b a b a b a
    (test-parseq '(parameter-slist-user-user) '(a) t '(a nil) nil)
    (test-parseq '(parameter-slist-user-user) '(a b a) t '(a ((b a))) nil)
    (test-parseq '(parameter-slist-user-user) '(a b a b a) t '(a ((b a) (b a))) nil)
    (test-parseq '(parameter-slist-user-user) '(a b a b a b a) t '(a ((b a) (b a) (b a))) nil)
    (test-parseq '(parameter-slist-user-user) '(a b a) t '(a ((b a))) nil)
    (test-parseq '(parameter-slist-user-user) '(a c a) t '(a ((c a))) nil)
    (test-parseq '(parameter-slist-user-user) '(a b a c a) t '(a ((b a) (c a))) nil)
    (test-parseq '(parameter-slist-user-user) '(a b a c a b a) t '(a ((b a) (c a) (b a))) nil)
    ;; 'a (:constant x)
    (test-parseq '(parameter-constant b) '(a) t 'b)))
    ;; Optional parameter
    (test-parseq 'parameter-optional '(a) t '(5 nil))
    (test-parseq '(parameter-optional) '(a) t '(5 nil))
    (test-parseq '(parameter-optional 1) '(a) t '(1 t))
    ;; Keyword parameter
    (test-parseq 'parameter-keyword '(a) t '(5 nil))
    (test-parseq '(parameter-keyword) '(a) t '(5 nil))
    (test-parseq '(parameter-keyword :x 1) '(a) t '(1 t))
    ;; Rest parameter
    (test-parseq 'parameter-rest '(a) t '())
    (test-parseq '(parameter-rest) '(a) t '())
    (test-parseq '(parameter-rest 1) '(a) t '(1))
    (test-parseq '(parameter-rest 1 2) '(a) t '(1 2))

(parseq:defrule in-brackets (x) (and "(" x ")"))
(parseq:defrule runtime-dispatch-literal-t () (in-brackets t))
(parseq:defrule runtime-dispatch-literal-nil () (in-brackets nil))
(parseq:defrule runtime-dispatch-specific-symbol () (in-brackets 'q))
(parseq:defrule runtime-dispatch-specific-character () (in-brackets #\q))
(parseq:defrule runtime-dispatch-specific-string () (in-brackets "test"))
(parseq:defrule runtime-dispatch-specific-vector () (in-brackets #(1 2 3)))
(parseq:defrule runtime-dispatch-specific-number () (in-brackets -4))
(parseq:defrule runtime-dispatch-character-set () (in-brackets (char "a-z")))
(parseq:defrule runtime-dispatch-any-character () (in-brackets char))
(parseq:defrule runtime-dispatch-any-standard-character () (in-brackets stdchar))
(parseq:defrule runtime-dispatch-any-alpha-character () (in-brackets alpha))
(parseq:defrule runtime-dispatch-any-digit-character () (in-brackets digit))
(parseq:defrule runtime-dispatch-any-alphanumeric-character () (in-brackets alphanumeric))
(parseq:defrule runtime-dispatch-any-byte () (in-brackets byte))
(parseq:defrule runtime-dispatch-any-symbol () (in-brackets symbol))
(parseq:defrule runtime-dispatch-any-keyword () (in-brackets keyword))
(parseq:defrule runtime-dispatch-any-form () (in-brackets form))
(parseq:defrule runtime-dispatch-any-atom () (in-brackets atom))
(parseq:defrule runtime-dispatch-any-list () (in-brackets list))
(parseq:defrule runtime-dispatch-any-cons () (in-brackets cons))
(parseq:defrule runtime-dispatch-any-vector () (in-brackets vector))
(parseq:defrule runtime-dispatch-any-number () (in-brackets number))
(parseq:defrule runtime-dispatch-any-integer () (in-brackets integer))
(parseq:defrule runtime-dispatch-any-string () (in-brackets string))

(define-test runtime-dispatch-test ()
  (check
    (test-parseq 'runtime-dispatch-literal-t '("(" t ")") t '("(" t ")"))
    (test-parseq 'runtime-dispatch-literal-t '("(" nil ")") nil nil)
    (test-parseq 'runtime-dispatch-literal-nil '("(" nil ")") t '("(" nil ")"))
    (test-parseq 'runtime-dispatch-literal-nil '("(" t ")") nil nil)
    (test-parseq 'runtime-dispatch-specific-symbol '("(" q ")") t '("(" q ")"))
    (test-parseq 'runtime-dispatch-specific-symbol '("(" p ")") nil nil)
    (test-parseq 'runtime-dispatch-specific-character '("(" #\q ")") t '("(" #\q ")"))
    (test-parseq 'runtime-dispatch-specific-character '("(" #\p ")") nil nil)
    (test-parseq 'runtime-dispatch-specific-string '("(" "test" ")") t '("(" "test" ")"))
    (test-parseq 'runtime-dispatch-specific-string '("(" "Test" ")") nil nil)
    (test-parseq 'runtime-dispatch-specific-string "(test)" t '("(" "test" ")"))
    (test-parseq 'runtime-dispatch-specific-string "(Test)" nil nil)
    (test-parseq 'runtime-dispatch-specific-vector #("(" 1 2 3 ")") t '("(" #(1 2 3) ")") nil equalp)
    (test-parseq 'runtime-dispatch-specific-vector #("(" 1 2 4 ")") nil nil nil equalp)
    (test-parseq 'runtime-dispatch-specific-vector '("(" #(1 2 3) ")") t '("(" #(1 2 3) ")") nil equalp)
    (test-parseq 'runtime-dispatch-specific-vector '("(" #(1 2 4) ")") nil nil nil equalp)
    (test-parseq 'runtime-dispatch-specific-number '("(" -4 ")") t '("(" -4 ")"))
    (test-parseq 'runtime-dispatch-specific-number '("(" +4 ")") nil nil)
    (test-parseq 'runtime-dispatch-character-set "(d)" t '("(" #\d ")"))
    (test-parseq 'runtime-dispatch-character-set "(5)" nil nil)
    (test-parseq 'runtime-dispatch-any-character "(d)" t '("(" #\d ")"))
    (test-parseq 'runtime-dispatch-any-character "(5)" t '("(" #\5 ")"))
    (test-parseq 'runtime-dispatch-any-alpha-character "(d)" t '("(" #\d ")"))
    (test-parseq 'runtime-dispatch-any-alpha-character "(5)" nil nil)
    (test-parseq 'runtime-dispatch-any-digit-character "(5)" t '("(" #\5 ")"))
    (test-parseq 'runtime-dispatch-any-digit-character "(d)" nil nil)
    (test-parseq 'runtime-dispatch-any-alphanumeric-character "(5)" t '("(" #\5 ")"))
    (test-parseq 'runtime-dispatch-any-alphanumeric-character "(d)" t '("(" #\d ")"))
    (test-parseq 'runtime-dispatch-any-alphanumeric-character "(.)" nil nil)
    (test-parseq 'runtime-dispatch-any-byte #("(" 255 ")") t '("(" 255 ")"))
    (test-parseq 'runtime-dispatch-any-byte #("(" 256 ")") nil nil)
    (test-parseq 'runtime-dispatch-any-byte #("(" 'x ")") nil nil)
    (test-parseq 'runtime-dispatch-any-symbol #("(" test ")") t '("(" test ")"))
    (test-parseq 'runtime-dispatch-any-symbol #("(" 3 ")") nil nil)
    (test-parseq 'runtime-dispatch-any-form #("(" test ")") t '("(" test ")"))
    (test-parseq 'runtime-dispatch-any-form #("(" nil ")") t '("(" nil ")"))
    (test-parseq 'runtime-dispatch-any-form #("(" ")") nil nil)))

(define-test option-test ()
  (check
    ;; (and 'a 'b 'c) (:constant 4)
    (test-parseq 'option-constant '(a b c) t 4)
    ;; (and 'a 'b 'c) (:lambda (x y z) (list z y x))
    (test-parseq 'option-lambda '(a b c) t '(c b a))
    ;; (and 'a 'b 'c) (:lambda (&rest items) (reverse items))
    (test-parseq 'option-lambda-rest '(a b c) t '(c b a))
    ;; (and (* 'a) 'b) (:destructure ((&rest a) b) `(,@a ,b))
    (test-parseq 'option-destructure '(a a a b) t '(a a a b))
    ;; (and 'a (* 'b) (rep 1 'c) (? (and (+ 'd) 'e)) 'f) (:choose 0 0 '(1 5) 2 '(3 1) '(3 0 0) -1 -10)
    (test-parseq 'option-choose '(a b c d e f) t '(a a nil (c) e d f nil))
    (test-parseq 'option-choose '(a b b b b b b b c d e f) t '(a a b (c) e d f nil))
    (test-parseq 'option-choose '(a c d e f) t '(a a nil (c) e d f nil))
    (test-parseq 'option-choose '(a b c f) t '(a a nil (c) nil nil f nil))
    ;; (and 'a 'b 'c) (:identity t)
    (test-parseq 'option-identity-t '(a b c) t '(a b c))
    ;; (and 'a 'b 'c) (:identity nil)
    (test-parseq 'option-identity-n '(a b c) t nil)
    ;; (and (and 'a 'b) (and 'c 'd) (and 'e 'f)) (:flatten)
    (test-parseq 'option-flatten '(a b c d e f) t '(a b c d e f))
    ;; (and (and #\a "b") "cd" (and #\e #\f)) (:string)
    (test-parseq 'option-string "abcdef" t "abcdef")
    (test-parseq 'option-string '(#\a "b" "cd" #\e #\f) t "abcdef")
    (test-parseq 'option-string #(#\a "b" "cd" #\e #\f) t "abcdef")
    ;; (and (and #\a "b") "cd" (and #\e 'f)) (:string)
    (test-parseq 'option-string-symbol '(#\a "b" "cd" #\e f) t "abcdeF")
    (test-parseq 'option-string-symbol #(#\a "b" "cd" #\e f) t "abcdeF")
    ;; (and (and 1 2) (and 3 4) (and 5 6)) (:vector)
    (test-parseq 'option-vector '(1 2 3 4 5 6) t #(1 2 3 4 5 6) nil equalp)
    (test-parseq 'option-vector #(1 2 3 4 5 6) t #(1 2 3 4 5 6) nil equalp)
    ;; number (:test (x) (= x 5))
    (test-parseq 'option-test '(4) nil nil)
    (test-parseq 'option-test '(5) t 5)
    (test-parseq 'option-test '(6) nil nil)
    ;; number (:not (x) (= x 5))
    (test-parseq 'option-not '(4) t 4)
    (test-parseq 'option-not '(5) nil nil)
    (test-parseq 'option-not '(6) t 6)))

(define-test multiopt-test ()
  (check
    ;; number (:lambda (x) (1+ x)) (:lambda (x) (1+ x)))
    (test-parseq 'multiopt-proc '(5) t 7)
    ;; number (:test (x) (= x 5)) (:lambda (x) (1+ x)))
    (test-parseq 'multiopt-test-a '(4) nil nil)
    (test-parseq 'multiopt-test-a '(5) t 6)
    ;; number (:lambda (x) (1+ x)) (:test (x) (= x 5)))
    (test-parseq 'multiopt-test-b '(4) t 5)
    (test-parseq 'multiopt-test-b '(5) nil nil)))

(define-test nesting-test ()
  (check
    ;; (or (and 'a 'b) (and 'a 'c) (and 'd 'e))
    (test-parseq 'nest-or-and '(a) nil nil)
    (test-parseq 'nest-or-and '(a b) t '(a b))
    (test-parseq 'nest-or-and '(a c) t '(a c))
    (test-parseq 'nest-or-and '(a e) nil nil)
    (test-parseq 'nest-or-and '(d) nil nil)
    (test-parseq 'nest-or-and '(d e) t '(d e))

    ;; (and (or 'a 'b) (or 'a 'c) (or 'd 'e))
    (test-parseq 'nest-and-or '(a) nil nil)
    (test-parseq 'nest-and-or '(b) nil nil)
    (test-parseq 'nest-and-or '(a a) nil nil)
    (test-parseq 'nest-and-or '(b a) nil nil)
    (test-parseq 'nest-and-or '(a c) nil nil)
    (test-parseq 'nest-and-or '(b c) nil nil)
    (test-parseq 'nest-and-or '(a a d) t '(a a d))
    (test-parseq 'nest-and-or '(b a d) t '(b a d))
    (test-parseq 'nest-and-or '(a c d) t '(a c d))
    (test-parseq 'nest-and-or '(b c d) t '(b c d))
    (test-parseq 'nest-and-or '(a a e) t '(a a e))
    (test-parseq 'nest-and-or '(b a e) t '(b a e))
    (test-parseq 'nest-and-or '(a c e) t '(a c e))
    (test-parseq 'nest-and-or '(b c e) t '(b c e))

    ;; (* (and 'a 'b))
    (test-parseq 'nest-*-and '() t nil)
    (test-parseq 'nest-*-and '(a) nil nil)
    (test-parseq 'nest-*-and '(a) t nil t)
    (test-parseq 'nest-*-and '(a b) t)
    (test-parseq 'nest-*-and '(a b a) nil nil)
    (test-parseq 'nest-*-and '(a b a) t '((a b)) t)
    (test-parseq 'nest-*-and '(a b a b) t)

    ;; (and (* 'a 'b))
    (test-parseq 'nest-and-* '() t '(nil nil))
    (test-parseq 'nest-and-* '(a) t '((a) nil))
    (test-parseq 'nest-and-* '(a a) t '((a a) nil))
    (test-parseq 'nest-and-* '(b) t '(nil (b)))
    (test-parseq 'nest-and-* '(b b) t '(nil (b b)))
    (test-parseq 'nest-and-* '(a b) t '((a) (b)))
    (test-parseq 'nest-and-* '(a a b) t '((a a) (b)))
    (test-parseq 'nest-and-* '(a b b) t '((a) (b b)))

    ;; (+ (and 'a 'b))
    (test-parseq 'nest-+-and '() nil nil)
    (test-parseq 'nest-+-and '(a) nil nil)
    (test-parseq 'nest-+-and '(a b) t '((a b)))
    (test-parseq 'nest-+-and '(a b a) nil nil)
    (test-parseq 'nest-+-and '(a b a) t '((a b)) t)
    (test-parseq 'nest-+-and '(a b a b) t '((a b) (a b)))

    ;; (and (+ 'a 'b))
    (test-parseq 'nest-and-+ '() nil nil)
    (test-parseq 'nest-and-+ '(a) nil nil)
    (test-parseq 'nest-and-+ '(a a) nil nil)
    (test-parseq 'nest-and-+ '(b) nil nil)
    (test-parseq 'nest-and-+ '(b b) nil nil)
    (test-parseq 'nest-and-+ '(a b) t '((a) (b)))
    (test-parseq 'nest-and-+ '(a a b) t '((a a) (b)))
    (test-parseq 'nest-and-+ '(a b b) t '((a) (b b)))

    (test-parseq 'nest-list-list '(((a))) t '((a)))))

(define-test bind-test ()
  (check
    (test-parseq 'bind-single '(4 a a a) nil nil)
    (test-parseq 'bind-single '(4 a a a a) t '(4 (a a a a)))
    (test-parseq 'bind-single '(4 a a a a a) nil nil)
    (test-parseq 'bind-nest '(3 3 a a a 2 a a 7 a a a a a a a 1 a) nil nil)
    (test-parseq 'bind-nest '(4 3 a a a 2 a a 7 a a a a a a a 1 a) t '(4 ((3 (a a a)) (2 (a a)) (7 (a a a a a a a)) (1 (a)))))
    (test-parseq 'bind-nest '(5 3 a a a 2 a a 7 a a a a a a a 1 a) nil nil)
    (test-parseq 'bind-nest '(4 3 a a a 2 a a 6 a a a a a a a 1 a) nil nil)
    (test-parseq 'bind-nest '(4 3 a a a 2 a a 8 a a a a a a a 1 a) nil nil)))

(define-test namespace-test ()
  (check-with-side-effects
    ;; Sanity check
    (test-parseq 'nonterminal-and '(a b c) t '(a b c))
    ;; Local rules
    (parseq:with-local-rules
      (condition= (parseq:parseq 'nonterminal-and '(a b c)) parseq:unknown-rule-error))
    (parseq:with-local-rules
      (parseq:defrule nonterminal-and () (and 'd 'e 'f))
      (test-parseq 'nonterminal-and '(a b c) nil nil))
    (parseq:with-local-rules
      (parseq:defrule nonterminal-and () (and 'd 'e 'f))
      (test-parseq 'nonterminal-and '(d e f) t '(d e f)))
    ;; Saved rules
    (parseq:with-saved-rules
      (test-parseq 'nonterminal-and '(a b c) t '(a b c)))
    (parseq:with-saved-rules
      (parseq:defrule nonterminal-and () (and 'd 'e 'f))
      (test-parseq 'nonterminal-and '(d e f) t '(d e f)))
    ;; Clear rules
    (parseq:with-saved-rules
      (test-parseq 'nonterminal-and '(a b c) t '(a b c))
      (parseq:clear-rules)
      (condition= (parseq:parseq 'nonterminal-and '(a b c)) parseq:unknown-rule-error)
      (parseq:defrule nonterminal-and () (and 'd 'e 'f))
      (test-parseq 'nonterminal-and '(d e f) t '(d e f)))
    ;; Sanity check
    (test-parseq 'nonterminal-and '(a b c) t '(a b c))
    (test-parseq 'nonterminal-and '(d e f) nil nil)))

(define-test parse-error-test ()
  (check
    ;; parse-match-error
    ;; (and terminal-symbol (or (and 'b (* 'd) (parameter-terminal 'e)) (and 'c (or 'g 'h)) (and 'b 'f)))
    (condition= (parseq:parseq 'parse-error '(v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 0)) (equal (parseq:parse-error-terminals obj) '('a)))
    (condition= (parseq:parseq 'parse-error '(a v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 1)) (equal (parseq:parse-error-terminals obj) '('b 'c)))
    (condition= (parseq:parseq 'parse-error '(a b v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 2)) (equal (parseq:parse-error-terminals obj) '('d 'e 'f)))
    (condition= (parseq:parseq 'parse-error '(a c v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 2)) (equal (parseq:parse-error-terminals obj) '('g 'h)))
    (condition= (parseq:parseq 'parse-error '(a b d v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 3)) (equal (parseq:parse-error-terminals obj) '('d 'e)))
    (condition= (parseq:parseq 'parse-error '(a b d d v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 4)) (equal (parseq:parse-error-terminals obj) '('d 'e)))
    (condition= (parseq:parseq 'parse-error '(a b d d d v) :parse-error t) parseq:parse-match-error obj (parseq::treepos= (parseq:parse-error-position obj) (parseq::make-treepos 5)) (equal (parseq:parse-error-terminals obj) '('d 'e)))
    ;; parse-junk-error
    (condition= (parseq:parseq 'parse-error '(a b f v) :parse-error t) parseq:parse-junk-error)))

(define-test recursion-test ()
  (check
    (test-parseq 'recursion '() nil nil)
    (test-parseq 'recursion '(a) t 'a)
    (test-parseq 'recursion '(a a) t '(a a))
    (test-parseq 'recursion '(a a a) t '(a (a a)))
    (test-parseq 'recursion '(a a a a) t '(a (a (a a))))
    (test-parseq 'recursion '(a a a a a) t '(a (a (a (a a)))))))

(define-test left-recursion-test ()
  (check
    (condition= (parseq:parseq 'left-recursion-indirect '(a a a)) parseq:left-recursion-error)
    (condition= (parseq:parseq 'left-recursion '(a a a)) parseq:left-recursion-error)))

(define-test packrat-test ()
  (check
    (test-parseq 'packrat-symbol-user '(a b c) t '(a b c))
    (test-parseq 'packrat-abc-1 '(a b) t '((1 2 3 4 5 6) b))
    (test-parseq 'packrat-abc-2 '(a b) t '((1 2 4 4 5 6) b))
    (test-parseq 'packrat-abc-3 '(a b) t '((1 2 3 4 5 7) b))))

(define-test loop-test ()
  (check
    (test-parseq 'loop '(named q for a from 0 below 10 by 10) t)
    (test-parseq 'loop '(named q for a from 0 above -10 by 10) t)
    (test-parseq 'loop '(named q for a downfrom 0 above 10 by 10) t)
    (test-parseq 'loop '(named q for a in lst by #'cdr) t)
    (test-parseq 'loop '(named q for a = 0 then (1+ a)) t)
    (test-parseq 'loop '(named q for a across vec) t)
    (test-parseq 'loop '(named q for k being the hash-key of (hsh) using (hash-value v)) t)
    (test-parseq 'loop '(named q for v being the hash-value of (hsh) using (hash-key v)) t)
    (test-parseq 'loop '(named q for k being the external-symbol of (pkg)) t)
    (test-parseq 'loop '(for i in lst initially a b c while d) t)
    (test-parseq 'loop '(for i in list repeat 5) t)
    (test-parseq 'loop '(for i in list thereis (> i 0)) t)
    (test-parseq 'loop '(for i across vec when (> i 0) collecting it into q and summing i into n else maximize i into m and return 5 end) t)
    (test-parseq 'loop '(for i across vec unless (minusp i) count i into q) t)))

(define-test url-test ()
  (check
    (test-parseq 'url "http://github.com:22/mrossini-ethz/parseq?foo+bar+baz" t '("http://" "github.com" 22 "mrossini-ethz/parseq" ("foo" "bar" "baz")))))

(define-test parseq-test ()
  (check
    (treepos-test)
    (terminal-test)
    (and-test)
    (and~-test)
    (or-test)
    (not-test)
    (*-test)
    (+-test)
    (?-test)
    (&-test)
    (!-test)
    (rep-test)
    (list-test)
    (string-test)
    (string-type-test)
    (vector-test)
    (parse-test)
    (parameter-test)
    (runtime-dispatch-test)
    (option-test)
    (multiopt-test)
    (nesting-test)
    (bind-test)
    (namespace-test)
    (parse-error-test)
    (recursion-test)
    (left-recursion-test)
    (packrat-test)
    (loop-test)
    (url-test)))
